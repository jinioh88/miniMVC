## 데스크톱 애플리케이션
1. PC에 설치되어 실행되 웹 애플리케이션 보다 실행속도가 빠름.
    - office, 컴퓨터 게임 등등...
2. 문제점
  - 배포의 번거로움.
  - 보안에 취약 : 데이터 베이스에 접근할 때 취약 가능성
  - 애플리케이션 실행할 때 먼저 서버에 갱신된 버전이 있는지 조회 후 실행하면 어느정도 해결됨.
  - 단 보안에 취약...
  
## 클라이언트'서버 애플리케이션
  - 애플리케이션의 기능을 서버와 클라이언트로 분리.
  - 장점
    - 새로 프로그램이 수정 되도 서버 쪽만 변경하면 됨. 
    - 기능 변경/추가에 유연하게 대처가 됨. 
  - 문제점 개선 방안
    - 한번에 하나의 클라이언트 하고만 연결 됨. 
    - 멀티 프로세스와 멀티 스레드로 위 문제를 해결한다.
  - 멀티 프로세스와 멀티 스레드
    - 멀티 프로세스는 원본 프로세스의 메모리를 모두 복제해 자원 낭비가 심함.
    - 멀티 쓰레드는 전체 메모리를 복제할 필요가 없음. 
    
## 다중 클라이언트 요청 처리
  - 클라이언트의 요청 처리 부분을 별도의 작업으로 분리
  - 분리된 작업은 스레드에 정의
  - 다중 클라리언트 요청이 병행 처리됨.
  - C/S 환경의 프로그래밍이 복잡해지는 문제가 생김.
  
## 클라이언트'서버 아키텍처의 진화
1. 전통적인 클라이언트'서버 아키텍처
    - 서버는 데이터 처리를 맡고 클라이언트는 UI와 비즈니스를 처리했다.
    - 단점
        - 프로그램이 변경되면 PC에 다시 설치해야됨...
        - 클라이언트가 DBMS로 바로 접속해 보안 문제 발생.
        
2. 개선된 클라이언트'서버 아키텍처
    - 클라이언트의 업무 처리부분은 서버로 이관.
    - 클라이언트는 오직 UI만 담당.
    - 서버로부터 결과를 받으면 클라이언트에서 화면을 꾸며 뿌려줌. 
    - 애플리케이션 서버?
        - 업무를 전담하게된 서버를 애플리케이션 서버라 부른다. 
        - 클라이언트로부터 요청을 받으면 업무 로직에 따라 DBMS 서버를 사용해 데이터를 처리.
        - 클라이언트 접근제어도 함꼐 처리.
    - 서버에 기능이 변경 되도 바로 클라이언트에 적용할 수 있다. 

## 웹 애플리케이션 아키텍처
1. 특징
    - 클라이언트와 통신은 웹 서버가 전담
    - 애플리케이션 서버는 애플리케이션 서버 실행 및 관리에 집중.
    - 비즈니스 로직과 UI 로직을 모두 서버에 배치되 추가 변경되도 서버만 바꾸믄 된다. 
    - 단 웹 환경에선 애플리케이션 실행할 때마다 UI로직을 내려받기 때문에 오버헤드 발생.
    - 멀티 스레드 부분을 웹 브라우저와 웹 서버가 알아서 해줌. 
    
2. 서버쪽 
    - HttpServlet 클래스르르 상속받고 있다. 
    - doGet() / doPost()를 재정의 한다. 
    
3. 화면관련 오버헤드는 어떻게 극복할까?
    - AJAX
        - 같은 화면에서 데이터만 바뀔 때 서버에 UI 전체를 받아오기 보다, 데이터만 받아온다. 
 
 ## GET 요청
   - 결과 화면을 보관하거나 결과 화면을 다른 사람과 쉽게 공유하고 플때 사용한다. 
   - 이미지나 동영상 같은 바이너리 파일은 보낼 수 없다. 
   
## POST 요청
    - 요청 결과를 공유할 수 없다. 
    
## 파일 업로드
    - form 태그의 enctype을 multipart/form-data로 지정.
    - 메세지 보낼 때 '&', '='를 보내면 구분하기 어려워 boundary값을 이용한다.
    - 이 구분자는 웹 브라우저에서 임의로 생성함. 
    - 파트 구분자 다음 라인에 매개 변수가 온다. 
    - 매개변수 데이터가 파일이면 첨부파일 이름과 콘텐츠 유형 정보가 온다. 
    - 공백라인 이후 부터 다음 파트 구분자를 만날 떄 까지 첨부 파일 데이터가 온다. 
    
    
# 서블릿 프로그래밍
## CGI 프로그램과 서블릿
  - CGI 이해
    - 웹 애플리케이션 실행은 웹 브라우저가 웹 서버에게 실행을 요청한다.
    - 서버는 클라이언트가 요청한 프로그램을 찾아 실행하고, 해당 프로그그램은 작업을 수행 후 결과를 웹 서버에 전달한다. 
    - 그담 웹 서버는 HTTP 형식에 맞춰 브라우저에게 보낸다. 
    - 여기서 웹 서버와 프로그램 사잉에 데이터를 주고 받는 규칙을 CGI라 한다. 
    - 여기서 프로그램을 CGI 프로그램이라 한다. 
    - CGI 프로그램은 실행속도는 빠르지만, 변경이 있을시 매번 컴파일 하고 재 배포해야 한다. 
    - 이와 다르게 스크립트라는 방식은 실행할 때마다 소스 코드의 문법을 검증하고 해석해 실행 속도가 느리다. 
    - 하지만 변경사항 있을 시 단지 코드 수정만하면 되기 땜에 편리하다. 
  
  - 서블릿
    - 자바로 만든 CGI 프로그램을 서블릿 이라한다.
    - 서블릿 컨테이너 
        - 서블릿 생명주기를 관리. 서블릿을 대신해 CGI 규칙에 따라 웹 서버와 데이터 주고 받는다. 
    - 웹 서버 <---> 서블릿 컨테이너 <--> 서블릿
    
## 서블릿,JSP / Java EE / WAS
  - Java EE 기술은 기업용 어플리케이션과 클라우드 애플리케이션 개발에 필요한 여러가지 복합 기술을 정의하고 모아놓은 것.
  - WAS의 이해 
    - 클라이언트/서버 구조에서 서버쪽 애플리케이션의 생성과 실행, 소멸을 관리하는 프로그램을 애플리케이션서버라 한다.
    - 그 중 서블릿과 서블릿 컨테이너 같이 웹 기술을 기반으로 동작 하는 것을 애플리케이션서버를 WAS라 부른다.
    - Java에서 WAS란, Java EE 기술 사양을 준수해 만든 서버를 말한다. 
    - JEUS, WebLogin, WebSphere, JBoss 등이 있다. 
    - 서블릿 컨테이너 : Java EE 기술 중 서블릿, JSP 등 웹 과련 부분만 구현한 서버. 
    - 이런 서버를 '웹 컨테이너', '서블릿 컨테이너'라고도 하고 톰켓, 제티 등이 있다. 
    
## 서블릿 만들기
  - 서블릿 클래스는 반드시 javax.servlet.Servlet 인터페이스를 구현해야 한다. 
  - 서블릿 생명주기를 관리하는 메서드
    - init() : 초기화에 주로 이용.
    - service() : 클라이언트가 요청할 때 마다 호출되는 메서드. 서블릿이 해야할 일을 작성하믄 된다. 
    - destroy() : 서블릿 컨테이너가 종료, 웹 애플리케이션이 멈출 때, 또는 해당 서블릿이 비활성화 시킬 때 호출.  마무리작업을 작성하믄됨.
  - 기타 메서드
    - getServletConfig() : 서블릿 설정정보를 다루는 ServletConfig 객체 반환.
    - getServletInfo() : 서블릿 정보가 담김. 
    - 서블릿을 만들었으면 배치파일(web.xml) 약어로 'DD파일'에 등록해야 한다. 
    - DD 파일에 등록되지 않는 서블릿은 서블릿 컨테이너가 찾을 수 없다. 
    - <servlet-name>은 서블릿 별명을 설정. 
    - <servlet-class>는 패키지 이름을 포함한 서블릿 클래스명을 설정. 
    - 클라이언트에서 서블릿 실행을 요청할 때 URL을 사용. URL을 부여해야 클라이언트에서 요청할 수 있다. 
    - <servlet-mapping>태그로 서블릿과 URL을 매핑한다. 
    - 서블릿 구동 절차
        - 1) 클라이언트 요청이 오면 서블릿 컨테이너는 서블릿을 찾는다.
        - 2) 만약 서블릿이 없다면, 서블릿 클래스를 로딩하고 인스턴스 준비 후 생성자 호출한다.
        -    그리고 서블릿 초기화 메서드 init()을 호출한다. 
        - 3) 클라이언트 요청을 처리하는 service() 메서드 호출한다. 
        - 4) service() 메서드에서 만든 결과를 HTTP 프로토콜에 맞춰 클라이언트에 응답해서 요청처리를 완료한다. 
        - 5) 만약 서블릿 컨테이너를 종료하거나 웹 애플리케이션 종료하면 서블릿 컨테이너는 종료 전 destroy() 함수를 호출한다. 
     - 서블릿 컨테이너는 클라이언트로부터 요청이 오면 해당 서블릿을 찾아보고 없으면 해당 서블릿 인스턴스를 생성한다.
     - 한번 서블릿 객체가 생성되면 웹 애플리케이션을 종료할 때 까지 계속 유지한다. 
     - 웰컴 파일 
        - 웹 서버에 요청시 서블릿 이름을 생략하고, 디렉터리 위치까지만 입력하면 웹 서버는 해당 디렉터리의 웰컴 파일을 보내준다. 
        - web.xml에 <welcom-file-list> 안에 정의 되어 있다. 
        
## 웹 애플리케이션 배치
  - 웹 애플리케이션을 서블릿 컨테이너에 배치  
  - 운영 서버에 배치
    - 실 운영 서버에 배치할 땐 배치할 파일들을 하나의 웹 아카이브 파일(.war)로 만들어 배치 폴더에 복사한다. 
    
## GenericServlet 이용
  - GenericServlet은 추상메서드인데 하위 클래스에게 공통의 필드와 메서드를 상속해 주고자 존재. 
  - 서블릿 클래스가 필요로한 init(), destroy(), getServletConfig(), getServletInfo()를 미리 구현해 상속해 줌, 
  - service()는 각 서블릿 마다 구현해야 하므로, 구현 되지 않았음. 
  - 이로써 사용자는 service() 메서드만 구현해 주믄 되게 되었다.      
  - servie() 매개변수
    - ServletRequest : 클라이언트의 요청 정보를 다룰 때 사용. 
        - getParameter()는 GET이나 POST 요청이 들어온 매개변수 값을 꺼낼 때 사용. 
        > 
            localhost:8080/web01/show?a=20&b=10 요청을 했을 때 
            request.getParameter("a"); 하면 ? 뒤의 a 값이 들어가게 된다.
    - servletResponse : 응답과 관련된 기능 제공. 클라이언트에게 보낼때 사용. 
        - getWriter() : 클라이언트로 출력할 수 있도록 출력 스트림 객체를 반환. 바이너리 출력하고플땐 getOutputStream()이용.
        - getWriter() 호출 전에 setContenType(), setCharacterEncoding()을 먼저 호출해야 한다. 
  - @WebServlet 애노테이션을 이용한 서블릿 배치 정보 설정
    - Servlet3.0 이후 부터 애노테이션으로 서블릿을 배치할 수 있다. 
    - 작성한 서블릿 클래스 이름 위에 @WebServlet을 붙이믄 된다. 
    - 서블릿 URL 정보는 @WebServlet의 '()' 안에 넣는다.
        >   @WebServlet("show")
         

# 서블릿과 JDBC
## HttpServlet으로 GET요청 다뤄보기
  - HttpServlet 클래스를 사용하면 service() 메서드 대신, doGet(), doPost()를 정의해야 한다. 
  - 클라이언트 요청이 들어오면, 첫째로 상속받은 HttpServlet의 service() 메서드가 호출된다.
  - 그 다음 service()는 클라이언트 요청 방식에 따라 doGet(), doPost(), doPut()...등 메서드를 호출한다. 
  - 그러므로 service()메서드 직접 구현보단 doXXX()메서드를 오버라이딩 하자. 
  - GET 요청이니까 doGet()을 오버라이딩 하믄 된다. 
  - cf) 배치 정보가 바뀌었다면 서블릿 컨테이너를 다시 시작해야 한다.         
  - <form>태그의 action속성은 실행할 서블릿의 URL주소이다. 
  - method 속성이 'get'이면 해당 서블릿에 doGet()을 호출하고, 'post'면 doPost()를 호출하도록 한다.

## HttpServlet으로 POST요청 다뤄보기
  - doPost()를 오버라이딩 하자

## 리프래시
  - doPost() 메서드에서 다음 줄을 추가하자.
  - response.addHeader("Refresh", "1;url=list");  // '1'은 1초뒤 해당 url로 이동하라는 뜻. 상대경로로('/'가 안붙으면 상대경로)
  - 위는 HTTP 응답 정보에 헤더를 추가하는 작업이다. 
  - 작업 결과를 출력한 후 다른 페이지로 이동할땐 리프레시를 사용한다.
  - 작업 결과를 출력하지 않고 바로 다른 페이지로 이동할 경우 리다이렉트로 처리한다. 

## 리다이렉트
  - 서블릿이 응답값으로 이동할 페이지 URL 정보를 같이 보낸다.
  - 웹 브라우저가 이를 받는 즉시 해당 URL로 다시 요청한다.
  - 해당 서블릿은 해당 URL로 응답을 보낸다.
  - HttpServletRespnse의 sendRedirect()로 처리하면 된다.
  - response.sendRedirect("list");   
  - 리다이렉트는 클라이언트로 본문을 출력하지 않는다. 
  - 응답 코드는 302 이다. 이코드는 요청한 자원이 다른 URL로 이동되었으니 Location헤더에 있는 주소로 다시요청부탁해' 라는 뜻이다.

## 서블릿 초기화 매개변수
  - 서블릿을 생성하고 초기화 할때(init()호출), 서블릿 컨테이너가 전달하는 데이터이다. 
  - DD파일(web.xml)로 설정할 수도있고, 애노테이션으로 설정할 수 있다.
  - 가능한 소스코드와 분리해 외부 파일에 두는것을 추천한다. 
  - 데이터베이스 연결정보 같은 것을 둔다.
  - web.xml에서 <init-parm> 태그안에 작성하면 된다. 
  - 서블릿 초기화 매개변수들으느 오직 그 매개변수를 선언한 서블릿에서만 사용가능하다. 
  - 서블릿 클래스에서 this.getInitParameter("변수이름"); 으로 값을 가져온다. 

## 컨텍스트 초기화 매개변수
  - JDBC 드라이버와 연결정보같은 것을 각각의 서블릿 마다 초기화 매개변수를 선언한다면 너무 귀찮아진다.
  - 이런경우 컨텍스트 초기화 매개변수를 사용하도록 하자.
  - 같은 웹 애플리케이션에 소속된 서블릿들이 이를 공유하게 된다. 
  - web.xml에서 <context-param> 태그가 바로 이것이다. 
  - 해당 서블릿에서 사용하기 위해서 ServletContext sc = this.getServletContext(); 작성해 사용하도록 한다. 
  - sc.getInitParameter()로 초기화 매개변수값을 얻도록 한다. 

## 필터를 사용해보자
  - 필터는 서블릿 실행 전후에 어떤 작업을 할떄 사용하는 기술이다. 
  - 클라이언트 <--> 서블릿컨테이너 <--> 필터1 <--> 필터2 <--> 서블릿
  - 필터가 없었다면 서블릿안에 해당 작업을 넣어 줬어야 했다.
  - 예를 들어 POST 요청으로 메시지 바디에 한글 내용을 가져오려고 할때 setCharaterEncoding()을 해야한다.
  - 이 작업을 모든 서블릿에 적용한다면 유지보수에 좋지 안핟. 
  - 이럴때 서블릿 필터를 이용해 해결하면 된다. 
  - 필터는 javax.servlet.Filter 인터페이스를 구현하면 된다. 
  - init() : 필터 객체가 생성되고 나서 준비작업을 위해 딱 한번 호출 된다. 
  - doFilter() : 필터와 연결된 URL에 대해 요청이 들어오면 doFilter()가 항상 호출된다. 필터가 할 일을 작성하자. 
  - FilterChain nextFilter; //  다음 필터를 호출한다. 다음 필터가 없으면 내부적으로 서블릿의 service()를 호출한다. 
  - 사전작업 --> nextFileter.doFileter() --> 사후작업
  - DD파일에서 <filter> 안에 작성하면 된다. <filter-mapping>은 어떤 요청에 대해 필터를 적용할지 설정해준다. 
  - 애노테이션으로도 사용가능하다. 
 
 #MVC 아키텍처
 ## 뷰를 분리해보자
  - 서블릿에서 했던 페이지 작업을 JSP에 요청 위임하고, 서블릿에서 준비한 데이터를 JSP에 전달해본다.
  - 서블릿은 UI를 생성하지 않기 때문에 출력코드가 필요 없다. 그 대신 JSP가 화면을 만들 수 있도록 데이터를 준비해야 한다. 
  - ArrayList객체를 준비해 회원 목록을 담아 주자. ArrayList<Member> members = new ArrayList<Member>();
  - request에 회원 목록 데이터 보관한다.
	> 	request.setAttribute("members", members);
  - RequestDispatcher를 이용한 forward, include
    - 다른 서블릿이나 JSP로 작업을 위임할때 사용하는 객체가 RequestDispathcer이다. 
    - HttpServletRequest를 통해 얻는다. RequestDispatcher rd = request.getRequestDispatcher("/member/MemberListjsp");
    - Dispatcher 얻을 때, 반드시 어떤 서블릿(또는 JSP)로 위임할지 알려주야 한다. 
    - 이제 해당 jsp에서 서블릿이 넘겨준 회원 목록을 꺼내고자 request.getAttribute();를 호출한다. 
    - request는 JSP내장 객체가 선언안해도 사용가능하다. 
    - 출력은 다음 형식으로 한다. <a href='update?no=<%=member.getNo()%>'><%=member.getName()%></a>

## 포워딩과 인클루딩
  - 포워드 방식은 작업을 한번 위임하면 다시 이전 서블릿으로 제어권이 돌아가지 않는다. 
  - 인클루드 방식은 다른 서블릿으로 작업 위임 후, 그 서블릿이 끝나면 다시 이전 스블릿으로 제어권이 돌아간다. 
  - 예외가 발생하면 포워딩으로 예외 화면을 보여주자. 
  >
    catch (Exception e) {
			request.setAttribute("error", e);
			RequestDispatcher rd = request.getRequestDispatcher(
					"Error.jsp");
			rd.forward(request, response);

		}
  - 인클루딩은 화면 헤더와 푸터를 등록하는데 사용 된다. 
    > MemberList.jsp에 추가
      <jsp:include page="/Header.jsp"/>
      ...
      <jsp:include page="/Tail.jsp"/>

## 데이터 보관소
  - 서블릿 기술은 데이터 공유를 위해 4가지 종류의 데이터 보관소를 제공한다. 
  - 보관소는 공유 범위 기준으로 구분 된다. 
  - 1) ServletContext 보관소
    - 웹 애플리케이션이 시작될 때 생성되, 웹 애플리케이션 종료될때까지 유지. 
    - 모든 서블릿이 사용할 수 있다. 
  - 2) HttpSession 보관소
    - 클라이언트 최초 요청 시 생성되 브라우저 닫을때 까지 유지. 
    - 보통은 로그인할때 이 보관소 초기화 하고, 로그아웃하면 저장된 값들을 비운다. 
  - 3) ServletRequest 보관소
    - 클라이언트 요청이 들어올 떄 생성, 클라이언트에게 응답할 떄까지 유지됨. 
    - 포워딩, 인클루딩하는 서블릿들 사이에서 값을 공유할 때 유용. 
  4) JspContext 보관소
    - JSP 페이지를 실행하는 동안만 유지.
  
  - 보관소에 값을 넣고 쓰는 방법
    - 객체.setAttribute(키, 값); // 저장
    - 객체.getAttribute(키);
  - ServletContext의 활용
    - 데이터베이스 커넥션 객체 같은 것을 공유하고자 사용할떄 쓰면 된다. 
    - 이렇게 하면 데이터베이스를 이용하는 모든 서블릿은 ServletContext에서 DB 커넥션 객체를 가져올 수 있다. 
    - HttpServlet을 상속받은 클래스에서 init()에 작성한다.
    >  ServletContext sc = this.getServletContext();
       Class.forName(sc.getInitParameter("driver"); ...
       sc.setAttribute("coon",conn);  // 모든 서블릿이 사용할 수 있도록 ServletContext 객체에 저장한다. 
    - 서블릿 객체는 클라이언트의 최초 요청시 생성된다. 한번도 요청 없으면 그 서블릿은 생성안된다. 
    - 서블릿이 생성되기 전에 미리 작업을 준비해야 하는 서블릿의 경우 클라이언트 요청이 없더라도 생성된다.
    - DD파일에 servlet 등록시 <load-on-startup>1</load-on-startup> 태그를 추가해주자.
    - 이런 준비 서블릿의 경우 <servlet-mapping>  태그가 없다. 
    - 이제 기존에 서블릿마다 작성해 뒀던 Connction 소스를 다음과 같이 수정하면 된다.
    >   
        ServletContext sc = this.getServletContext();
			  conn = (Connection)sc.getAttribute("conn");
			  stmt = conn.createStatement();
			  rs = stmt.executeQuery(
				  	"SELECT MNO,MNAME,EMAIL,CRE_DATE" + 
				  	" FROM MEMBERS" +
				  	" ORDER BY MNO ASC");
			
			  response.setContentType("text/html; charset=UTF-8");
  - HttpSession 활용 - 로그인
    - 클라이언트 당 한개가 생성된다. 
    - 웹 브라우저 요청이 들어오면, 그 웹 브라우저를 위한 HttpSession 객체가 있는지 검사하고, 없으면 새로 HttpSession객체 만든다.
    - 일정기간 동안 Timeout요청이 없으면 삭제된다. 
    - /auth/login 서블릿 요청이 있을 때 LoginServlet은 회원 정보를 데이터베이스에 찾아 Member에 담고, 다른 서블릿들이 참조할 수 있도록 HttpSession객체에 보관한다. 



          
